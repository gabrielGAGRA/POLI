Excelente. Agora que temos um sistema bem definido como base (o App de Caronas), posso te dar exemplos muito mais concretos de como e por que você usaria esses três padrões para estender a funcionalidade dele.
Usar um contexto familiar é a melhor maneira de entender a aplicação prática de cada padrão. Vamos lá.
Padrão Método de Fábrica (Factory Method)
O Problema Concreto (No App de Caronas):
O sistema precisa notificar os usuários sobre eventos importantes (ex: "Sua viagem foi confirmada", "O motorista cancelou a viagem"). Atualmente, o sistema não faz nada. Queremos implementar um sistema de notificações, mas sabemos que no futuro, alguns usuários preferirão receber notificações por E-mail, outros por SMS, e talvez até por Push Notification no celular.
A classe SistemaDeCaronas não deve ter um if/else para decidir como notificar. Ela só quer dizer "notifique este usuário", e a forma de notificação deve ser decidida em outro lugar, talvez com base na preferência do usuário.
A Solução com o Padrão:
Vamos usar o Factory Method para adiar a decisão de qual notificador criar. Criaremos uma hierarquia de "Fábricas de Notificadores". A classe Usuario poderá ter uma preferência por um tipo de fábrica.
Como Fica a Estrutura (UML):
 * Produto (Product): INotificador (interface com método enviar(usuario, mensagem)).
 * Produtos Concretos (ConcreteProduct): NotificadorEmail, NotificadorSMS.
 * Criador (Creator): NotificadorFactory (classe abstrata com o método de fábrica criarNotificador()).
 * Criadores Concretos (ConcreteCreator): EmailFactory e SMSFactory, que implementam criarNotificador() para retornar a instância correta.
Exemplo em Código (Integrado ao Sistema):
1. Crie a pasta notifications/ dentro de src/
/notifications/INotificador.java
package notifications;
import model.Usuario;

// A interface do Produto
public interface INotificador {
    void enviar(Usuario usuario, String mensagem);
}

/notifications/NotificadorEmail.java
package notifications;
import model.Usuario;

// Produto Concreto
public class NotificadorEmail implements INotificador {
    @Override
    public void enviar(Usuario usuario, String mensagem) {
        System.out.printf("[EMAIL] Enviando para %s: '%s'\n", usuario.getNome(), mensagem);
    }
}

/notifications/NotificadorSMS.java
package notifications;
import model.Usuario;

// Produto Concreto
public class NotificadorSMS implements INotificador {
    @Override
    public void enviar(Usuario usuario, String mensagem) {
        System.out.printf("[SMS] Enviando para %s: '%s'\n", usuario.getNome(), mensagem);
    }
}

2. Crie a pasta factories/ dentro de src/
/factories/NotificadorFactory.java
package factories;
import notifications.INotificador;

// O Criador Abstrato (Creator)
public abstract class NotificadorFactory {
    // Pode ter lógica comum aqui.
    public void notificarUsuario(model.Usuario usuario, String mensagem) {
        // Delega a criação para o método de fábrica.
        INotificador notificador = criarNotificador();
        notificador.enviar(usuario, mensagem);
    }
    
    // O Método de Fábrica que as subclasses devem implementar.
    protected abstract INotificador criarNotificador();
}

/factories/EmailFactory.java
package factories;
import notifications.*;

// Criador Concreto
public class EmailFactory extends NotificadorFactory {
    @Override
    protected INotificador criarNotificador() {
        return new NotificadorEmail();
    }
}

(A SMSFactory seria idêntica, mas retornando new NotificadorSMS())
3. Como o SistemaDeCaronas utilizaria isso:
Imagine um método dentro de SistemaDeCaronas para confirmar um passageiro.
// Dentro da classe system.SistemaDeCaronas
public void confirmarPassageiro(Viagem viagem, Usuario passageiro) {
    // ... lógica para adicionar passageiro ...
    viagem.adicionarPassageiro(passageiro);

    // Notificar o passageiro usando a fábrica de sua preferência (que poderia ser um atributo do usuário)
    NotificadorFactory factory = new EmailFactory(); // Simulação da preferência do usuário
    factory.notificarUsuario(passageiro, "Sua carona para " + viagem.getDestino() + " foi confirmada!");
    
    // Notificar o motorista
    NotificadorFactory factoryMotorista = new SMSFactory(); // Motorista prefere SMS
    factoryMotorista.notificarUsuario(viagem.getMotorista(), passageiro.getNome() + " entrou na sua viagem.");
}

Vantagem Direta: Para adicionar notificações "Push", basta criar NotificadorPush e PushFactory. O SistemaDeCaronas não precisa ser alterado.
Padrão Fábrica Abstrata (Abstract Factory)
O Problema Concreto (No App de Caronas):
O sistema precisa processar pagamentos. No futuro, ele deverá suportar múltiplos gateways de pagamento (MercadoPago, Stripe, PIX). Cada gateway tem um processo diferente e gera um tipo de comprovante diferente.
Por exemplo, um pagamento com MercadoPago envolve:
 * Um objeto GatewayMercadoPago para processar a cobrança.
 * Um objeto GeradorReciboPDF para gerar o comprovante.
Um pagamento com PIX envolve:
 * Um objeto GatewayPIX que gera um QR Code.
 * Um objeto GeradorReciboJSON para o comprovante.
A GatewayMercadoPago e o GeradorReciboPDF formam uma família de objetos que devem ser usados juntos. O mesmo para a família PIX. O sistema não pode misturar um gateway de um tipo com um gerador de recibo de outro.
A Solução com o Padrão:
Usar uma Fábrica Abstrata (IPagamentoFactory) que define como criar uma família completa de objetos de pagamento. Teremos fábricas concretas como MercadoPagoFactory e PIXFactory.
Como Fica a Estrutura (UML):
 * Fábrica Abstrata (AbstractFactory): IPagamentoFactory (com métodos criarGateway() e criarGeradorRecibo()).
 * Fábricas Concretas (ConcreteFactory): MercadoPagoFactory, PIXFactory.
 * Produtos Abstratos (AbstractProduct): IGatewayPagamento, IGeradorRecibo.
 * Produtos Concretos (ConcreteProduct): GatewayMercadoPago, GeradorReciboPDF, GatewayPIX, GeradorReciboJSON.
Exemplo em Código (Integrado ao Sistema):
1. Crie a pasta payments/ dentro de src/
/payments/IPagamentoFactory.java (A Fábrica Abstrata)
package payments;

public interface IPagamentoFactory {
    IGatewayPagamento criarGateway();
    IGeradorRecibo criarGeradorRecibo();
}

/payments/IGatewayPagamento.java (Produto Abstrato 1)
package payments;

public interface IGatewayPagamento {
    boolean cobrar(double valor);
}

/payments/IGeradorRecibo.java (Produto Abstrato 2)
package payments;

public interface IGeradorRecibo {
    void gerar(String transacaoId);
}

2. Crie a família MercadoPago
/payments/MercadoPagoFactory.java
package payments;

public class MercadoPagoFactory implements IPagamentoFactory {
    @Override public IGatewayPagamento criarGateway() { return new GatewayMercadoPago(); }
    @Override public IGeradorRecibo criarGeradorRecibo() { return new GeradorReciboPDF(); }
}

/payments/GatewayMercadoPago.java
package payments;

public class GatewayMercadoPago implements IGatewayPagamento {
    @Override public boolean cobrar(double valor) {
        System.out.printf("Cobrando R$%.2f via API do MercadoPago...\n", valor);
        return true;
    }
}

/payments/GeradorReciboPDF.java
package payments;

public class GeradorReciboPDF implements IGeradorRecibo {
    @Override public void gerar(String transacaoId) {
        System.out.printf("Gerando recibo PDF para a transação %s.\n", transacaoId);
    }
}

(A família PIX seria criada de forma análoga)
3. Como o estado EstadoConcluida utilizaria isso:
// Dentro da classe state.EstadoConcluida
@Override
public void finalizar(Viagem viagem) {
    System.out.println("Lógica de finalização da viagem iniciada...");
    
    // O sistema define qual fábrica usar (pode ser global ou por usuário)
    IPagamentoFactory fabricaDePagamento = new MercadoPagoFactory();

    // O código abaixo não sabe nada sobre "MercadoPago".
    // Ele só trabalha com as interfaces abstratas.
    IGatewayPagamento gateway = fabricaDePagamento.criarGateway();
    IGeradorRecibo recibo = fabricaDePagamento.criarGeradorRecibo();

    for (Usuario passageiro : viagem.getPassageiros()) {
        boolean sucesso = gateway.cobrar(viagem.getValorPorPassageiro());
        if (sucesso) {
            recibo.gerar("TRANSACAO_" + viagem.getId() + "_" + passageiro.getId());
        }
    }

    System.out.println("Viagem " + viagem.getId() + " concluída e cobranças processadas.");
    // A transição de estado permaneceria aqui
}

Vantagem Direta: Para suportar "Stripe", basta criar a StripeFactory e seus produtos. A lógica de cobrança dentro de EstadoConcluida não muda, pois ela depende apenas das interfaces.
Padrão Façade (Fachada)
O Problema Concreto (No App de Caronas):
Queremos adicionar uma funcionalidade de "Verificação de Segurança do Motorista". Esse processo é complexo e envolve múltiplos passos com sistemas externos:
 * Verificar a validade da CNH no sistema do Detran.
 * Consultar o histórico de antecedentes criminais na Polícia Federal.
 * Verificar o score de crédito do motorista em um serviço como o Serasa.
A classe SistemaDeCaronas, ao criar uma viagem, não quer ter que lidar com a complexidade de chamar esses três serviços, tratar seus erros e combinar os resultados.
A Solução com o Padrão:
Criar uma classe VerificacaoSegurancaFacade que oferecerá um único método, verificarMotorista(motorista). Essa fachada esconderá toda a complexidade de interagir com os subsistemas do Detran, Polícia e Serasa.
Como Fica a Estrutura (UML):
 * Façade (Facade): VerificacaoSegurancaFacade.
 * Subsistema (Subsystem Classes): ServicoDetran, ServicoPoliciaFederal, ServicoSerasa.
 * Cliente (Client): A classe SistemaDeCaronas.
Exemplo em Código (Integrado ao Sistema):
1. Crie a pasta external/ dentro de src/
/external/ServicoDetran.java (Subsistema 1)
package external;
import model.Usuario;

public class ServicoDetran {
    public boolean cnhEstaValida(Usuario motorista) {
        System.out.println("Consultando sistema do Detran para " + motorista.getNome());
        return true; // Simulação
    }
}

(ServicoPoliciaFederal e ServicoSerasa seriam similares)
2. Crie a classe da Fachada
/system/VerificacaoSegurancaFacade.java
package system;

import external.*; // Importa as classes do subsistema
import model.Usuario;

public class VerificacaoSegurancaFacade {
    private final ServicoDetran detran = new ServicoDetran();
    private final ServicoPoliciaFederal policia = new ServicoPoliciaFederal();
    private final ServicoSerasa serasa = new ServicoSerasa();

    // O método simples que esconde toda a complexidade.
    public boolean motoristaEstaApto(Usuario motorista) {
        System.out.println("\n--- Iniciando verificação de segurança completa para " + motorista.getNome() + " ---");
        
        if (!detran.cnhEstaValida(motorista)) {
            System.err.println("REPROVADO: CNH inválida.");
            return false;
        }
        if (!policia.temFichaLimpa(motorista)) {
            System.err.println("REPROVADO: Possui antecedentes.");
            return false;
        }
        if (serasa.getScore(motorista) < 500) {
            System.err.println("REPROVADO: Score de crédito baixo.");
            return false;
        }
        
        System.out.println("APROVADO: Motorista passou em todas as verificações de segurança.");
        return true;
    }
}

3. Como o SistemaDeCaronas utilizaria isso:
// Dentro da classe system.SistemaDeCaronas

// A fachada pode ser um membro da classe.
private final VerificacaoSegurancaFacade verificacaoFacade = new VerificacaoSegurancaFacade();

public Viagem criarViagem(String partida, String destino, int assentos, double valor, Usuario motorista) {
    // Antes de criar a viagem, o sistema usa a fachada para uma verificação simples.
    if (!verificacaoFacade.motoristaEstaApto(motorista)) {
        // Lança uma exceção ou retorna nulo, impedindo a criação da viagem.
        throw new SecurityException("Motorista " + motorista.getNome() + " não passou na verificação de segurança.");
    }
    
    // Se passou, a lógica normal de criação da viagem continua...
    Viagem novaViagem = new Viagem(partida, destino, assentos, valor, motorista);
    this.viagens.add(novaViagem);
    return novaViagem;
}

Vantagem Direta: O SistemaDeCaronas não sabe nada sobre Detran ou Serasa. Ele faz uma única chamada de alto nível (motoristaEstaApto). Se o processo de verificação mudar (adicionar um quarto serviço), apenas a classe VerificacaoSegurancaFacade é alterada.
